//
// Copyright (c) 2017, chunquedong
// Licensed under the Apache Licene 2.0
//
//  Created by yangjiandong on 2017/8/20.
//

#include "PodGen.hpp"
#include "ir/FCodeUtil.hpp"


PodGen::PodGen(PodLoader *podMgr, const std::string& podName) : podMgr(podMgr), podName(podName) {
    module = new IRModule();
    
    pod = podMgr->findPod(podName);
    
    allTypes.clear();
    allTypes.reserve(pod->types.size());
    for (int i=0; i<pod->types.size(); ++i) {
        FType *type = &pod->types[i];
        TypeGen gtype(type, module->defType(type));
        gtype.c_sortFlag = 0;
        
        //if (gtype.name != "testlib_Main") continue;
        allTypes.push_back(gtype);
    }
    
    for (int i=0; i<allTypes.size(); ++i) {
        TypeGen *t = &allTypes[i];
        typeMap[t->name] = t;
    }
    
    topoSortType();
}

PodGen::~PodGen() {
    delete module;
    module = NULL;
}

void printDocComment(Printer &printer) {
    printer.println("/*");
    printer.println("This file is generated by funrun. Do Not Edit.");
    printer.println("*/");
}

void PodGen::gen(const std::string &path) {
    std::string headerFile = path + podName + ".h";
    Printer headerPrinter(headerFile.c_str());
    printDocComment(headerPrinter);
    genHeader(&headerPrinter);
    
    std::string impleFile = path + podName + ".c";
    Printer implePrinter(impleFile.c_str());
    printDocComment(implePrinter);
    genImple(&implePrinter);
    
    std::string regisFile = path + podName + "_prototype.h";
    Printer prototypePrinter(regisFile.c_str());
    printDocComment(prototypePrinter);
    genNativePrototype(&prototypePrinter);
    
    /*
    std::string regisFile = path + podName + "_register.c";
    Printer regisPrinter(regisFile.c_str());
    genRegister(&regisPrinter);
    
    std::string stubFile = path + podName + "_stub.c";
    Printer stubPrinter(stubFile.c_str());
    genStub(&stubPrinter);
     */
}

void PodGen::horizontalLine(Printer *printer, const char *name) {
    printer->newLine();
    printer->_print("//");
    for (int i=0; i<80; ++i) {
        printer->_print("#");
    }
    if (name) {
        printer->_print("  ");
        printer->_print(name);
    }
    printer->newLine();
    printer->newLine();
}


void PodGen::genHeader(Printer *printer) {
    printer->println("#ifndef _%s_h_", podName.c_str());
    printer->println("#define _%s_h_", podName.c_str());
    
    printer->println("#ifdef __cplusplus");
    printer->println("extern \"C\" {");
    printer->println("#endif //__cplusplus");
    
    printer->println("#include \"runtime/runtime.h\"");
    for (int i=0; i<pod->c_dependPods.size(); ++i) {
        std::string& dep = pod->c_dependPods[i];
        printer->println("#include \"%s.h\"", dep.c_str());
    }
    printer->newLine();
    
    horizontalLine(printer, "type declare");
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->genTypeDeclare(printer);
        printer->newLine();
    }
    
    horizontalLine(printer, "struct");
    bool hasNative = false;
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        if (gtype->type->c_isNative) {
            hasNative = true;
            break;
        }
    }
    if (hasNative) {
        //printer->println("#include \"%s/pod_%s_native.h\"", podName.c_str(), podName.c_str());
        //printer->println("#include \"%s/pod_%s_struct.h\"", podName.c_str(), podName.c_str());
        printer->newLine();
    }
    
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->genStruct(printer);
        printer->newLine();
        gtype->genStaticField(printer, true);
        printer->newLine();
    }
    
    horizontalLine(printer, "method declare");
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->genMethodDeclare(printer);
        printer->newLine();
    }
    
    horizontalLine(printer, "virtual table");
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->genVTable(printer);
        printer->newLine();
    }
    
    printer->println("void %s_init__(fr_Env __env);", podName.c_str());
    
    printer->println("#ifdef __cplusplus");
    printer->println("}//extern C");
    printer->println("#endif //__cplusplus");
    printer->println("#endif //_%s_h_", podName.c_str());
}

void PodGen::genNativePrototype(Printer *printer) {
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->genNativePrototype(printer);
        printer->newLine();
    }
}

void PodGen::genImple(Printer *printer) {
    
    printer->println("#include \"%s.h\"", podName.c_str());
    printer->newLine();
    
    genConstPool(printer);
    
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->genImple(printer);
        //printer->newLine();
    }
    
    genStaticInit(printer);
}

void PodGen::genConstPool(Printer *printer) {
    int size = pod->constantas.strings.size();
    if (size == 0) size = 1;//C not allow empty array
    printer->println("fr_Obj %s_ConstPoolStrs[%d] = {0};", podName.c_str(), size);

    size = pod->constantas.uris.size();
    if (size == 0) size = 1;
    printer->println("fr_Obj %s_ConstPoolUris[%d] = {0};", podName.c_str(), size);

    size = pod->constantas.durations.size();
    if (size == 0) size = 1;
    printer->println("fr_Obj %s_ConstPoolDurations[%d] = {0};", podName.c_str(), size);

    size = pod->constantas.decimals.size();
    if (size == 0) size = 1;
    printer->println("fr_Obj %s_ConstPoolDecimals[%d] = {0};", podName.c_str(), size);
}

void PodGen::genStaticInit(Printer *printer) {
    printer->println("void %s_init__(fr_Env __env) {", podName.c_str());
    printer->indent();
    printer->println("static bool inited = false;");
    printer->println("if (inited) { return; }");
    printer->println("inited = true;");
    
    for (int i=0; i<pod->c_dependPods.size(); ++i) {
        std::string& dep = pod->c_dependPods[i];
        if (dep == podName) continue;
        printer->println("%s_init__(__env);", dep.c_str());
    }
    
    printer->newLine();
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->irType->initVTable();
        int vtableSize = 0;
        for (int j=0; j<gtype->irType->vtables.size(); ++j) {
            IRVTable *vtable = gtype->irType->vtables[j];
            vtableSize += vtable->functions.size();
        }
        
        printer->println("%s_class__ = (fr_Type)"
                         "malloc(sizeof(struct fr_Class_) + (%d * sizeof(void*)) );"
                         , gtype->name.c_str(), vtableSize);
        printer->println("%s_initClass__(__env, (struct fr_Class_ *)%s_class__);"
                         , gtype->name.c_str(), gtype->name.c_str());
        printer->newLine();
    }
    
    printer->newLine();
    printer->newLine();
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        std::string staticInit = "static$init";
        auto itr = gtype->type->c_methodMap.find(staticInit);
        if (itr != gtype->type->c_methodMap.end()) {
            printer->println("FR_STATIC_INIT(%s);", gtype->name.c_str());
        }
    }
    
    printer->newLine();
    printer->newLine();
    
    printer->println("struct fr_Pod_ *pod = (struct fr_Pod_ *)malloc(sizeof(struct fr_Pod_));");
    printer->println("pod->name = \"%s\";", podName.c_str());
    printer->println("pod->version = \"%s\";", pod->version.c_str());
    printer->println("pod->depends = \"%s\";", pod->depends.c_str());
    
    printer->println("pod->metaCount = %d;", 0);
    printer->println("pod->metas = NULL;");
    
    printer->println("fr_registerPod(__env, pod);");
    
    printer->unindent();
    printer->println("}");
}
/*
void PodGen::genRegister(Printer *printer) {
    printer->println("#include \"%s.h\"", podName.c_str());
    printer->newLine();
    
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->genMethodWrap(printer);
    }
    printer->println("void %s_register(fr_Fvm vm) {", podName.c_str());
    printer->indent();
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->genMethodRegister(printer);
    }
    printer->unindent();
    printer->println("}");
}

void PodGen::genStub(Printer *printer) {
    printer->println("#include \"%s.h\"", podName.c_str());
    //printer->println("#include \"fni.h\"");
    printer->newLine();
    
    for (int i=0; i<sortedTypes.size(); ++i) {
        TypeGen *gtype = sortedTypes[i];
        gtype->genMethodStub(printer);
    }
}
*/


//////////////////////////////////////////////////
// sort

static TypeGen *getOne(PodGen *pod) {
    for (size_t i=0,n=pod->allTypes.size(); i<n; ++i) {
        TypeGen &type = pod->allTypes[i];
        if (type.c_sortFlag != 0 ) {
            continue;
        }
        return &type;
    }
    return NULL;
}

void PodGen::accType(const std::string &name) {
    TypeGen* type = findType(name);
    if (type == NULL) return;

    if (type->c_sortFlag != 0) {
        return;
    }
    type->c_sortFlag = 1;

    if (type->name == "sys_Obj") {
        sortedTypes.push_back(type);    
        return;
    }

    std::string baseName = FCodeUtil::getTypeNsName(pod, type->type->meta.base);
    accType(baseName);

    for (int i = 0; i < type->type->meta.mixin.size(); ++i) {
        std::string baseName = FCodeUtil::getTypeNsName(pod, type->type->meta.mixin[i]);
        accType(baseName);
    }

    for (FField& field : type->type->fields) {
        if (FCodeUtil::isValueTypeRef(pod, field.type)) {
            std::string fieldTypeName = FCodeUtil::getTypeNsName(pod, field.type);
            accType(fieldTypeName);
        }
    }

    sortedTypes.push_back(type);
}

void PodGen::topoSortType() {
    sortedTypes.clear();
    
    TypeGen *type = getOne(this);
    while (type) {
        accType(type->name);
        type = getOne(this);
    }
}

////////////////////////////////////////////////////////////

TypeGen* PodGen::findType(const std::string &name) {
    auto it = typeMap.find(name);
    if (it == typeMap.end()) {
        return NULL;
    } else {
        return it->second;
    }
}


